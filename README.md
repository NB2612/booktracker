# Дневник чтения — архитектура и паттерны

## SOLID

### Single Responsibility Principle (Принцип единственной ответственности)

Каждый класс должен иметь только одну ответственность и одну причину для изменения.

В проекте класс `BookRepository` отвечает только за операции с данными книг — добавление, удаление, поиск.  
Если объединить логику UI и работу с данными, например в `MainController`, класс станет сложным и нарушит SRP.

### Open/Closed Principle (Принцип открытости/закрытости)

Код открыт для расширения, но закрыт для модификации.

Фильтрация книг реализована с возможностью добавлять новые фильтры без изменения базового кода — через паттерн Strategy (см. ниже).  
Это позволяет расширять функциональность без риска поломать существующий код.

### Liskov Substitution Principle (Принцип подстановки Лисков)

Наследники класса `Book` (например, `EBook`) могут использоваться вместо базового класса без нарушения логики приложения.

Если бы для каждого типа книги пришлось писать отдельные методы, это бы усложнило код и нарушило LSP.

### Interface Segregation Principle (Принцип разделения интерфейсов)

Интерфейсы должны быть узконаправленными.

Пока в проекте достаточно одного интерфейса `BookRepository` с базовыми методами.  
В будущем при усложнении бизнес-логики интерфейс можно разделить на несколько более специализированных.

### Dependency Inversion Principle (Принцип инверсии зависимостей)

Классы зависят от абстракций, а не от конкретных реализаций.

Вместо создания экземпляров репозитория внутри контроллеров зависимости передаются через конструктор.  
Это улучшает тестируемость и упрощает замену реализации.

---

## Принцип YAGNI (You Aren't Gonna Need It)

В проекте пока не реализуются сложные разделения интерфейсов и другие паттерны, которые не нужны по текущим требованиям.  
Например, интерфейсное разделение репозитория пока не нужно.

---

## Принцип DRY (Don't Repeat Yourself)

Повторяющийся код, например проверка корректности UUID, вынесен в утилитный класс `UUIDUtils`.  
Это уменьшает дублирование и повышает надежность.

---

## Применение паттернов

### Strategy (Стратегия)

Используется для фильтрации списка книг. Фильтры оформлены как отдельные классы, реализующие общий интерфейс:

```java
public interface BookFilterStrategy {
    boolean test(Book book);
}
